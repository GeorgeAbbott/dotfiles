wr() {
	nvim "$HOME/docs/wr/$1"
}

mnsec() { # Make an encrypted (secure entry).
	[ -z "$DEFAULT_GPG" ] && echo "DEFAULT_GPG not set" && return 
	mkdir -p "/tmp/mksec"
	nvim "/tmp/mksec/$1"
	gpg --encrypt --armor --symmetric -r "$DEFAULT_GPG"  --output "$HOME/docs/wr/sec/$1" "/tmp/mksec/$1"
	rm "/tmp/mksec/$1"
}

rdsec() { # Read a secure entry, will NOT write it back after. 
	[ ! -f "$HOME/docs/wr/sec/$1" ] && echo "File $1 does not exist" && return
	mkdir -p "/tmp/mksec"
	gpg -d --output "/tmp/mksec/$1.decrypted" "$HOME/docs/wr/sec/$1"
	nvim "/tmp/mksec/$1.decrypted"
	rm "/tmp/mksec/$1.decrypted"
}

mdsec() { # Modify a secure entry, writing it back after. 
	[ -z "$DEFAULT_GPG" ] && echo "DEFAULT_GPG not set" && return
	[ ! -f "$HOME/docs/wr/sec/$1" ] && echo "File $1 does not exist" && return
	mkdir -p "/tmp/mksec"
	gpg -d --output "/tmp/mksec/$1.decrypted" "$HOME/docs/wr/sec/$1"
	nvim "/tmp/mksec/$1.decrypted"
	gpg --encrypt --armor --symmetric -r "$DEFAULT_GPG" --output "$HOME/docs/wr/sec/$1" "/tmp/mksec/$1.decrypted"
	rm "/tmp/mksec/$1.decrypted"

}

lssec() {
	ls "$HOME/docs/wr/sec" $@
}

mnrec() {
	wr "rec/$1"
}

mnkic() {
	wr "kic/$1"
}

mndream() { # Dream Record: D~
	if [ -z $1 ] ; then DT="yesterday" else DT="$1" fi 
	mkdir -p "$HOME/docs/wr/dream"
	wr "dream/D$(date --iso-8601 -d $DT).txt"
}

rddream() {
	if [ -z "$1" ] ; then 
		wr "dream"
		return 
	else
		wr "dream/D$(date --iso-8601 -d $DT).txt"
	fi
}

mn() { # Make note 
	wr "mn/$1"
}

lle() { # Life Log Entry: L~
    if [ -z $1 ] ; then DT="today" else DT="$1" fi
    mkdir -p "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)"
    wr "lle/$(date +%Y-%m -d $DT)/L$(date --iso-8601 -d $DT).txt"
}

# Make a holiday. For instance, mkhol 2022-11 draycott creates a directory 
# in $HOL, which is normally $LLE/hol, or ~/docs/wr/lle/hol. The directory is 
# 2022-11-draycott. Then you can refer to the name or the month in mnhol and 
# holc.
mkhol() {
	if [ -z "$HOLIDAY" ] ; then HOL="$HOLIDAY" else HOL="$HOME/docs/wr/lle/hol" fi
	if [ -z "$1" ] ; then 
		# TODO: add logic to verify the date is valid
		echo "You need to provide a date parameter"; return; fi
	if [ -z "$2" ] ; then echo "Please enter a place where you went.";
		return; fi

	mkdir -p "$HOL/$1-$2"
}

# Make and edit the metadata associated with a holiday.
mnholmd() { # Provide a date and name. 
	# basic checks 
	if [ -z "$HOLIDAY" ] ; then HOL="$HOLIDAY" else HOL="$HOME/docs/wr/lle/hol" fi
	if [ -z "$1" ] ; then 
		# TODO: add logic to verify the date is valid
		echo "You need to provide a date parameter"; return; fi
	if [ -z "$2" ] ; then echo "Please enter a place where you went.";
		return; fi
	# logic
	if [ ! -d "$HOL/$1-$2" ] ; then echo "$1-$2 does not exist"; return; fi
	if [ -f "$HOL/$1-$2/md" ] ; then 
		nvim "$HOL/$1-$2/md"
	else
		echo "begin=\nend=\nwith=\nat=\n" >> "$HOL/$1-$2/md"
		nvim "$HOL/$1-$2/md"
	fi
}

# Make an entry in the holiday; this is a replacement for holc. It is called 
# ev~ as it relies on an envvar. Set EVMNHOL_DIR to the directory you want to
# put the entries in, and then pass the date as the parameter. Then write up ya
# entry! 
evmnhol() {
	if [ -z "$EVMNHOL_DIR" ] ; then echo "EVMNHOL_DIR is not set"; return; fi 
	if [ -z "$1" ] ; then echo "You need to pass a date"; return; else DT="$1" fi 
	if [ ! -d "$HOLIDAY/$EVMNHOL_DIR" ] ; then echo "$HOLIDAY/$EVMNHOL_DIR does not exist"; return; fi 

	# TODO: add logic to verify the date using md. But check md actually 
	# exists first. Use date +%s -d "$(cat md | grep begin | cut -d'=' -f2)"

	mkdir -p "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)"
	wr "lle/$(date +%Y-%m -d $DT)/H$(date --iso-8601 -d $DT).txt"
	ln -s "../../$(date +%Y-%m -d $DT)/H$(date --iso-8601 -d $DT).txt" "$HOLIDAY/$EVMNHOL_DIR/H$(date --iso-8601 -d $DT).txt"
}

holc () { # Holiday Entry: H~. Run with the holiday, e.g. draycott 2022-11-12.
    if [ -z $1 ] ; then DT="today" else DT="$1" fi
    mkdir -p "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)"
    nvim "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)/H$(date --iso-8601 -d $DT).txt"

}

mer() { # Month End Recap: M~
    if [ -z $1 ] ; then DT="yesterday" else DT="$1" fi
    mkdir -p "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)"
    nvim "$HOME/docs/wr/lle/$(date +%Y-%m -d $DT)/M$(date +%Y-%m -d $DT).txt" 
}

# Run with the year.
yer() { # Year End Recap: Y~
    if [ -z $1 ] ; then DT="yesterday" else DT="$1" fi
    mkdir -p "$HOME/docs/wr/lle/$1-12"
    nvim "$HOME/docs/wr/lle/$1-12/Y$1.txt"
}

# old atd and cld, soon to be gotten rid of anyways
# todos... (changed to a~ so it doesn't clash with orgd binaries)
abbrev-alias atd="wr td/todos"
abbrev-alias atdcmp="wr td/todos-cmp"
abbrev-alias atdntd="wr td/todos-ntd"

abbrev-alias cld="wr cld/calendar" 
abbrev-alias cldcmp="wr cld/calendar-cmp"
abbrev-alias cldrec="wr cld/calendar-recurring"

# mnfin 
alias mnfin='cd ~/docs/wr/trk/fin/; nvim $(date +%Y-%m)'

# kt: commands for kt (this should really be in orgd, but oh well for now)
abbrev-alias kt="wr orgd/kt"
abbrev-alias bm="wr orgd/kt/bm"
abbrev-alias coast="wr orgd/kt/coast"
abbrev-alias bib="wr orgd/kt/biblio"
abbrev-alias bibmanga="wr orgd/kt/biblio-manga"
abbrev-alias bibfut="wr orgd/kt/biblio-fut"
abbrev-alias bibrmfut="wr orgd/kt/biblio-rmfut" # For moved out of fut, but where to keep the notes still
